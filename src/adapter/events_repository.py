import psycopg2
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT

from src.adapter.db import *

class EventsRepository:

    def __init__(self, host, port, user, password, db_name):
        """ Create users and domain databases """
        self.con = psycopg2.connect(
            user=user, password=password, host=host, port=port)
        self.con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)

        with self.con.cursor() as cursor:
            sql_create_database = f"CREATE DATABASE {db_name};"
            try:
                cursor.execute(sql_create_database)
            except psycopg2.errors.DuplicateDatabase:
                print('[+] Events database already exists')

            sql_create_table = f'''CREATE TABLE IF NOT EXISTS events (
                                        event_id serial PRIMARY KEY,
                                        image VARCHAR (64) NOT NULL,
                                        description VARCHAR( 1000 ) NOT NULL,
                                        product_heading VARCHAR( 100 ) NOT NULL,
                                        category VARCHAR( 64 ) NOT NULL,
                                        event_tickets INT NOT NULL,
                                        total_tickets INT NOT NULL,
                                        progress_perc DECIMAL(5,2) CHECK (progress_perc >= 0 AND progress_perc <= 100.00) DEFAULT 0.00,
                                        sell_product_price numeric( 8, 2 ),
                                        event_prompt VARCHAR( 64 ) NOT NULL,
                                        active BOOLEAN NOT NULL DEFAULT TRUE,
                                        winner_id INT,
                                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                                        FOREIGN KEY (winner_id) REFERENCES users(user_id)
                                );'''
            cursor.execute(sql_create_table)

#GENERATED BY DEFAULT AS IDENTITY

    def get_all_ids(self, active): #Will get all Event ID's, all you have to choose is if active is True or False
        with self.con.cursor() as cursor:
            cursor.execute("SELECT event_id FROM events WHERE active=bool(%s)", (active,))
            result = cursor.fetchall()
            if len(result) != 0:
                return result
            else:
                #FIXME - What happens when there is no event
                return []

    def get_category_ids(self, category, active): #Will get all Event ID's by categories, all you have to choose is the category and if active is True or False
        with self.con.cursor() as cursor:
            cursor.execute("SELECT event_id FROM events WHERE category=%s AND active=bool(%s);", (category, active)) 
            result = cursor.fetchall()
            if len(result) != 0:
                return result
            else:
                #FIXME - What happens when there is no event
                return []

    def get_all_params(self, event_id): #Will get all column data of a row based on the chosen event_id
        with self.con.cursor() as cursor:
            cursor.execute("SELECT * FROM events WHERE event_id=%s;", (event_id,))
            result = cursor.fetchone()
            if len(result) != 0:
                return result
            else:
                #FIXME - What happens when there is no event
                return None

    def publish_event(self, image, description, product_heading, category, event_tickets, total_tickets, sell_product_price, event_prompt): #Will insert the requested Event data into the Events Table, and will return the event_id
        with self.con.cursor() as cursor:
            cursor.execute("INSERT INTO events(image, description, product_heading, category, event_tickets, total_tickets, sell_product_price, event_prompt) VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING event_id;",
                           (image, description, product_heading, category, event_tickets, total_tickets, sell_product_price, event_prompt))
            event_id = cursor.fetchone()
        return event_id[0]

    def update_event(self, image, description, product_heading, category, sell_product_price, event_id):
        with self.con.cursor() as cursor:
            cursor.execute("UPDATE events SET image = COALESCE(%s, image), description = COALESCE(%s, description), product_heading = COALESCE(%s, product_heading), category = COALESCE(%s, category), sell_product_price = COALESCE(%s, sell_product_price) WHERE event_id=%s;",
                           (image, description, product_heading, category, sell_product_price, event_id))

    def delete_event(self, event_id):
        with self.con.cursor() as cursor:
            cursor.execute("DELETE FROM events WHERE event_id=%s;", (event_id,))

    def list_events(self):
        with self.con.cursor() as cursor:
            cursor.execute("SELECT event_id, product_heading, category, sell_product_price, event_tickets, total_tickets, event_prompt, active, winner_id, created_at FROM events;")
            result = cursor.fetchall()
            if len(result) != 0:
                return result
            else:
                return None

    def update_perc(self, progress_perc, event_id):
        with self.con.cursor() as cursor:
            cursor.execute("UPDATE events SET progress_perc=%s WHERE event_id=%s", (progress_perc, event_id))

    def end_event(self, winner_id, event_id): #Will be done once an event has run out of time or has been completely sold out, this will update active state, the end time and who the winner was
        with self.con.cursor() as cursor:
            cursor.execute("UPDATE events SET active = FALSE, event_prompt = CLOCK_TIMESTAMP(), winner_id = %s WHERE event_id=%s;", (winner_id, event_id))

database_events = EventsRepository(host=os.getenv("POSTGRES_HOSTNAME", "localhost"), port="5432", user=db_user, password=db_password, db_name=events_db_name)
